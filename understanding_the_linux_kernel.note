                                                Understanding the Linux Kernel (Third Edition)
Linux kernel version : 2.6

Chapter 1 : Introducation
    Linux joins System V Release 4 (SVR4),developed by AT&T.
    other UNIX OS or UNIX-like OS :
      4.4 BSD
      Digital UNIX
      AIX
      HP-UX
      Solaris
      Mac OS X
      ...

      (opensource)
      FreeBSD
      NetBSD
      OpenBSD
      Linux
      ...

    The common attributes between Linux and well-known commercial Unix kernels :
      monolithic kernel
      compiled and statically linked traditional Unix kernels
      (of course support module for dynamically load and unload)
      kernel threading
      multithreaded application support(lightweight process LWP supporting)
      preemptive kernel
      multiprocessor support(SMP)
      filesystem

      streams(but Linux has no analogue to the STREAMS I/O subsystem introduced in SVR4)  

    The advantages of Linux :
      Linux is cost-free
      Linux is fully customizable in all its components
      Linux runs on low-end,inexpensive hardware platforms
      Linux is powerful
      Linux developers are excellent programmers
      The linux kernel can be very small and compact
      Linux is highly compatible with many common operating systems
      Linux is well supported

    Basic Operating System Concepts :
      the operating system must fulfill two main objectives :
        >  interact with the hardware components,servicing all low-level programmable elements
	   included in the hardware platform.
	>  provide an execution environment to the applications that run on the computer system.
	
      modern OS does not allow user program interact with hardware directly and forbid them to
      access arbitrary memory locations.
      in particular,the hardware introduces at least two different execution modes for the CPU :
        a nonprivileged mode for user programs
	a privileged mode for the kernel
	/*  UNIX calls these
	 *    User Mode and Kernel Mode
	 */

    Multiuser Systems :
      A multiuser system is a computer that is able to concurrently and independently execute several
      applications belonging to two or more users.

      Concurrently :
        applications can be active at the same time and contend for various resources such as CPU,memory,
	hard disks,and so on.
      Independently :
        each application can perform its task with no concern for what the applications of the other uses are
	doing.

      Multiuser operating systems must include several features :
        >  An authentication mechanism for verifying the user's identify
	>  A protection mechanism against buggy user programs that could block other applications running 
	   in the system
	>  A protection mechanism against malicious user programs that could interfere with or spy on the 
	   activity of other users
	>  An accounting mechanism that limits the amount of resource units assigned to each user

      To ensure safe protection mechanisms,operating systems must use the hardware protection associated 
      with the CPU privileged mode.
      Unix is a multiuser system that enforces the hardware protection of system resources.

    Users and Groups :
      in a multiuser system,each user has a private space on the machine,the operating system must ensure that
      the private portion of a user space is visible only to its owner.Unix-like system use UserID or UID as
      user identifier,it is a unique number.
      to selectively share material with other users,each user is a member of one or more user groups,which 
      are identified by a unique number called a user group ID.each file is associated with exactly one group.
      any Unix-like operating system has a special user called root or superuser,the root user can do almost
      everything,because the operating system does not apply the usual protection mechanism to it.

    Processes :
      A process can be defined either as "an instance of a program in execution" or  as the "execution context"
      of a running program.
      in traditional operating systems,a process executes a single sequence of instructions in an address space;
      the address space is the set of memory addresses that the process is allowed to reference.

      multiple processes environment :
        in modern operating system allow processes with multiple execution flows,that is,multiple sequences
	of instructions executed in the same address space.
	system that allow concurent active processes are said to be multiprogramming or multiprocessing.

	multiuser systems must enforce an multiple processes environment,but some multiprocessing operating
	systems are not multiuser.

	it is important to distinguish programs from processes;several processes can execute the same program
	concurently,while the same process can execute several programs sequentially.

	scheduler is an important system compoent in multiprocessing system,which process should be hold the 
	CPU to execute is determined by scheduler.
	
	preemptable :
	  some operating systems allow only nonpreemptable processes,which means that the scheduler is invoked
	  only when a process voluntarily relinquishes the CPU.but process of a multiuser system must be
	  preemptable.

	  UNIX is a multiuer and multiprocessing operating system with  preemptable processes.

	UNIX-like operating systems adopt a process/kernel model.each process has the illusion that it is the
	only process on the machine,and it has exclusive access to the operating system services.

    Kernel Architecture :
      monolithic kernel,each kernel layer is integrated into the whole kernel program and runs in Kernel Mode
      on behalf of the current process.

      microkernel operating systems demand a very small set of functions from the kernel,generally including a 
      few synchronization primitives,a simple scheduler,and an interprocess communication mechanism.
      several system processes that run on top of the microkernel implement other operating system layer functions,
      like memory allocators,device drivers,and system call handlers.

      comparison between monolithic kernel and microkernel :
        1>  microkernel is slower than monolithic kernel,because kernel layer communication has a cost.
	2>  microkernel force the system programmers to adopt a modularized approach,that means microkernel
	    is very modularized.every relativly kernel layer is independent program that must interact with
	    the other layers through well-defined and clean software interfaces.
	3>  microkernel can be easily ported to other architectures fairly easily.all hardware-dependent components
	    are generally encapsulated in the microkernel code.
        4>  microkernel tend to make better use of random access memory than monolithic kernel,system processes
	    that are not implementing needed functionalities might be swapped out or destroyed.

      UNIX and UNIX-like operating system almost satisfy all advantages of microkernel.

      the main advantages of using modules include :
        >  a modularized approach.
	>  platform independence
	>  frugal main memory usage
	>  no performance penalty

    An Overview of Unix Filesystem :
      the UNIX operating system design is centered on its filesystem,which has several interesting characteristics.

        Files - A Unix file is an information container structured as a sequence of bytes;the kernel does not
	      	interpret the contents of a file.

        Hard and Soft Links - A filename included in a directory is called a file hard link,or more simply,a link.
	     	      	      Soft links also called symbolic links,symbolic links are short files that contain an
			      arbitrary pathname of another file.

			      Hard links limitations :
			        it is not possible to create hard links for directories.
				links can be created only among files included in the same filesystem.

	File Types - File type represent what the file is.
	     	     Unix files may have one of the following types :
		       Regular file
		       Directory
		       Symbolic link
		       Block-oriented device file
		       Character-oriented device file
		       Pipe and named pipe
		       Socket

	File Descriptor and Inode - A file descriptor is a number greater than or equal to zero,the number
	     		    	    associared with a file data structure which represent the file opened by
				    process.
				    All information needed by the filesystem to handle a file is included in a 
				    data structure called an inode.each file has its own inode,which the filesystem
				    uses to identify the file.

        Access Rights and File Mode - there are three types of access rights :
	       	      	       	      read
				      write
				      execute
				      /*  access rights occupied nine bits  */
				      
				      Three additonal flags :
				      suid(Set User ID)
				      sgid(Set Group ID)
				      sticky - an executable file with the sticky flag set corresponds to request to
				      	       the kernel to keep the program in memory after its execution terminates.

				      File Mode is a mode mixed Access Rights and Additonal flags.

         File-Handling System Calls -  kernel provide some primitives to user mode to help user interact with actual
	 	       	      	       file stored in block device.
				       opening a file - open
				       accessing an opened file - read write lseek ...
				       closing a file - close
				       renaming and deleting a file - rename unlink link ...
				       
    An Overview of Unix Kernels :
      Unix kernels provide an execution environment in which applications may run.
      
      The Process/Kernel Model - Actually,some CPUs can have more than two execution states,but all standard Unix
      	  		       	 kernels use only Kernel Mode and User Mode.
				 A program usually executes in User Mode and switches to Kernel Mode only when requesting
				 a service provided by the kernel.when the kernel has satisfied the program's request,it
				 puts the program back in User Mode.the way is system calls.
				 after sets up parameters of syscall,then executes the hardware-dependent CPU instruction to
				 switch from User Mode to Kernel Mode.
				 Unix systems include a few privileged processes called kernel threads with the following
				 characteristics :
				   >  they run in Kernel Mode in the kernel address space
				   >  they do not interact with users,and thus do not require terminal devices
				   >  they are usually created during system startup and remain alive until the system
				      is shut down.
				 Unix kernels do much more than handle system calls;in fact,kernel routines can be actived
				 in several ways :
				   >  A process invokes a system call
				   >  the CPU executing the process signals an exception,which is an unusual condition such as
				      an invalid instruction.the kernel handles the exception on behalf of the process that 
				      caused it.
				   >  A peripheral device issues an interrupt signal to the CPU to notify it of an event such
				      as a request for attention,a status change,of the completion of an I/O operation.
				      each interrupt signal is dealt by a kernel program called an interrupt handler.
				   >  A kernel thread is executed.because it runs in Kernel Mode,the corresponding program
				      must be considered part of the kernel.

      Process Implementation - To let the kernel manage processes,each process is represented by a process descriptor that
      	      		       includes information about the current state of the process.
			       that include :
			         >  the program counter(PC) and stack pointer(SP) registers
				 >  the general purpose registers
				 >  the floating point registers
				 >  the processor control registers(Processor Status Word) containing information about
				    the CPU state
				 >  the memory management registers used to keep track of the RAM accessed by the process

			       When a process is scheduled,then kernel use the former stored information to recover process status,
			       and set IP to the next instruction.(it also known as PC,process counter,but IP is a instruction
			       register)

      Reentrant Kernels - All Unix kernels are reentrant.this means that several processes may be executing in Kernel Mode at
      			  the same time.of course,on uniprocessor systems,only one process can progress,but many can be blocked
			  in Kernel Mode when waiting for the CPU or the completion of some I/O operation.
			  reentrant functions : the functions they modify only local variables and do not alter global data 
			  	    	      	structures.
			  (reentrant functions,that is how some real-time kernels are implemented)
			  but kernel can include nonreentrant functions and use locking mechanisms to ensure that only one process
			  can execute a nonreentrant function at a time.

			  generial kernel control path :
			    Run process -> Timer interrupt -> Deal with interrupt -> Schedule tasks -> Run process -> ...

			  when one of the following events occurs,the CPU will enter a new path to do something :
			    >  a process executing in User Mode invokdes a system call.if the service would not be satisfied,
			       then scheduler pick next process to run,the former process enter sleeping until condition is
			       satisifed or wake up by a signal.
			       (system calls is triggered via soft interrupt,on x86,it is "int 0x80")
			    >  the CPU detects an exception.CPU must starts the execution of a suitable procedure.
			       after the procedure terminates,CPU return to the path before the exception is detected.
			    >  a hardware interrupt occurs,and the interrupts enabled.
			       CPU must starts processing another kernel control path to handle the interrupt.
			    >  an interrupt occurs while the CPU is running with kernel preemption enabled,and a higher priority
			       process is runnable.(lower intterupt could be preempted by higher interrupt)

			  three states of CPU current be :
			    >  running a process in User Mode			(process context)
			    >  running an exception or a system call handler	(process context)
			    >  running an interrupt handler	     		(interrupt context)
