                                                Understanding the Linux Kernel (Third Edition)
Linux kernel version : 2.6

Chapter 1 : Introducation
    Linux joins System V Release 4 (SVR4),developed by AT&T.
    other UNIX OS or UNIX-like OS :
      4.4 BSD
      Digital UNIX
      AIX
      HP-UX
      Solaris
      Mac OS X
      ...

      (opensource)
      FreeBSD
      NetBSD
      OpenBSD
      Linux
      ...

    The common attributes between Linux and well-known commercial Unix kernels :
      monolithic kernel
      compiled and statically linked traditional Unix kernels
      (of course support module for dynamically load and unload)
      kernel threading
      multithreaded application support(lightweight process LWP supporting)
      preemptive kernel
      multiprocessor support(SMP)
      filesystem

      streams(but Linux has no analogue to the STREAMS I/O subsystem introduced in SVR4)  

    The advantages of Linux :
      Linux is cost-free
      Linux is fully customizable in all its components
      Linux runs on low-end,inexpensive hardware platforms
      Linux is powerful
      Linux developers are excellent programmers
      The linux kernel can be very small and compact
      Linux is highly compatible with many common operating systems
      Linux is well supported

    Basic Operating System Concepts :
      the operating system must fulfill two main objectives :
        >  interact with the hardware components,servicing all low-level programmable elements
	   included in the hardware platform.
	>  provide an execution environment to the applications that run on the computer system.
	
      modern OS does not allow user program interact with hardware directly and forbid them to
      access arbitrary memory locations.
      in particular,the hardware introduces at least two different execution modes for the CPU :
        a nonprivileged mode for user programs
	a privileged mode for the kernel
	/*  UNIX calls these
	 *    User Mode and Kernel Mode
	 */

    Multiuser Systems :
      A multiuser system is a computer that is able to concurrently and independently execute several
      applications belonging to two or more users.

      Concurrently :
        applications can be active at the same time and contend for various resources such as CPU,memory,
	hard disks,and so on.
      Independently :
        each application can perform its task with no concern for what the applications of the other uses are
	doing.

      Multiuser operating systems must include several features :
        >  An authentication mechanism for verifying the user's identify
	>  A protection mechanism against buggy user programs that could block other applications running 
	   in the system
	>  A protection mechanism against malicious user programs that could interfere with or spy on the 
	   activity of other users
	>  An accounting mechanism that limits the amount of resource units assigned to each user

      To ensure safe protection mechanisms,operating systems must use the hardware protection associated 
      with the CPU privileged mode.
      Unix is a multiuser system that enforces the hardware protection of system resources.

    Users and Groups :
      in a multiuser system,each user has a private space on the machine,the operating system must ensure that
      the private portion of a user space is visible only to its owner.Unix-like system use UserID or UID as
      user identifier,it is a unique number.
      to selectively share material with other users,each user is a member of one or more user groups,which 
      are identified by a unique number called a user group ID.each file is associated with exactly one group.
      any Unix-like operating system has a special user called root or superuser,the root user can do almost
      everything,because the operating system does not apply the usual protection mechanism to it.

    Processes :
      A process can be defined either as "an instance of a program in execution" or  as the "execution context"
      of a running program.
      in traditional operating systems,a process executes a single sequence of instructions in an address space;
      the address space is the set of memory addresses that the process is allowed to reference.

      multiple processes environment :
        in modern operating system allow processes with multiple execution flows,that is,multiple sequences
	of instructions executed in the same address space.
	system that allow concurent active processes are said to be multiprogramming or multiprocessing.

	multiuser systems must enforce an multiple processes environment,but some multiprocessing operating
	systems are not multiuser.

	it is important to distinguish programs from processes;several processes can execute the same program
	concurently,while the same process can execute several programs sequentially.

	scheduler is an important system compoent in multiprocessing system,which process should be hold the 
	CPU to execute is determined by scheduler.
	
	preemptable :
	  some operating systems allow only nonpreemptable processes,which means that the scheduler is invoked
	  only when a process voluntarily relinquishes the CPU.but process of a multiuser system must be
	  preemptable.

	  UNIX is a multiuer and multiprocessing operating system with  preemptable processes.

	UNIX-like operating systems adopt a process/kernel model.each process has the illusion that it is the
	only process on the machine,and it has exclusive access to the operating system services.

    Kernel Architecture :
      monolithic kernel,each kernel layer is integrated into the whole kernel program and runs in Kernel Mode
      on behalf of the current process.

      microkernel operating systems demand a very small set of functions from the kernel,generally including a 
      few synchronization primitives,a simple scheduler,and an interprocess communication mechanism.
      several system processes that run on top of the microkernel implement other operating system layer functions,
      like memory allocators,device drivers,and system call handlers.

      comparison between monolithic kernel and microkernel :
        1>  microkernel is slower than monolithic kernel,because kernel layer communication has a cost.
	2>  microkernel force the system programmers to adopt a modularized approach,that means microkernel
	    is very modularized.every relativly kernel layer is independent program that must interact with
	    the other layers through well-defined and clean software interfaces.
	3>  microkernel can be easily ported to other architectures fairly easily.all hardware-dependent components
	    are generally encapsulated in the microkernel code.
        4>  microkernel tend to make better use of random access memory than monolithic kernel,system processes
	    that are not implementing needed functionalities might be swapped out or destroyed.

      UNIX and UNIX-like operating system almost satisfy all advantages of microkernel.

      the main advantages of using modules include :
        >  a modularized approach.
	>  platform independence
	>  frugal main memory usage
	>  no performance penalty

    An Overview of Unix Filesystem :
      the UNIX operating system design is centered on its filesystem,which has several interesting characteristics.

        Files - A Unix file is an information container structured as a sequence of bytes;the kernel does not
	      	interpret the contents of a file.

        Hard and Soft Links - A filename included in a directory is called a file hard link,or more simply,a link.
	     	      	      Soft links also called symbolic links,symbolic links are short files that contain an
			      arbitrary pathname of another file.

			      Hard links limitations :
			        it is not possible to create hard links for directories.
				links can be created only among files included in the same filesystem.

	File Types - File type represent what the file is.
	     	     Unix files may have one of the following types :
		       Regular file
		       Directory
		       Symbolic link
		       Block-oriented device file
		       Character-oriented device file
		       Pipe and named pipe
		       Socket

	File Descriptor and Inode - A file descriptor is a number greater than or equal to zero,the number
	     		    	    associared with a file data structure which represent the file opened by
				    process.
				    All information needed by the filesystem to handle a file is included in a 
				    data structure called an inode.each file has its own inode,which the filesystem
				    uses to identify the file.

        Access Rights and File Mode - there are three types of access rights :
	       	      	       	      read
				      write
				      execute
				      /*  access rights occupied nine bits  */
				      
				      Three additonal flags :
				      suid(Set User ID)
				      sgid(Set Group ID)
				      sticky - an executable file with the sticky flag set corresponds to request to
				      	       the kernel to keep the program in memory after its execution terminates.

				      File Mode is a mode mixed Access Rights and Additonal flags.

         File-Handling System Calls -  kernel provide some primitives to user mode to help user interact with actual
	 	       	      	       file stored in block device.
				       opening a file - open
				       accessing an opened file - read write lseek ...
				       closing a file - close
				       renaming and deleting a file - rename unlink link ...
				       
    An Overview of Unix Kernels :
      Unix kernels provide an execution environment in which applications may run.
      
      The Process/Kernel Model - Actually,some CPUs can have more than two execution states,but all standard Unix
      	  		       	 kernels use only Kernel Mode and User Mode.
				 A program usually executes in User Mode and switches to Kernel Mode only when requesting
				 a service provided by the kernel.when the kernel has satisfied the program's request,it
				 puts the program back in User Mode.the way is system calls.
				 after sets up parameters of syscall,then executes the hardware-dependent CPU instruction to
				 switch from User Mode to Kernel Mode.
				 Unix systems include a few privileged processes called kernel threads with the following
				 characteristics :
				   >  they run in Kernel Mode in the kernel address space
				   >  they do not interact with users,and thus do not require terminal devices
				   >  they are usually created during system startup and remain alive until the system
				      is shut down.
				 Unix kernels do much more than handle system calls;in fact,kernel routines can be actived
				 in several ways :
				   >  A process invokes a system call
				   >  the CPU executing the process signals an exception,which is an unusual condition such as
				      an invalid instruction.the kernel handles the exception on behalf of the process that 
				      caused it.
				   >  A peripheral device issues an interrupt signal to the CPU to notify it of an event such
				      as a request for attention,a status change,of the completion of an I/O operation.
				      each interrupt signal is dealt by a kernel program called an interrupt handler.
				   >  A kernel thread is executed.because it runs in Kernel Mode,the corresponding program
				      must be considered part of the kernel.

      Process Implementation - To let the kernel manage processes,each process is represented by a process descriptor that
      	      		       includes information about the current state of the process.
			       that include :
			         >  the program counter(PC) and stack pointer(SP) registers
				 >  the general purpose registers
				 >  the floating point registers
				 >  the processor control registers(Processor Status Word) containing information about
				    the CPU state
				 >  the memory management registers used to keep track of the RAM accessed by the process

			       When a process is scheduled,then kernel use the former stored information to recover process status,
			       and set IP to the next instruction.(it also known as PC,process counter,but IP is a instruction
			       register)

      Reentrant Kernels - All Unix kernels are reentrant.this means that several processes may be executing in Kernel Mode at
      			  the same time.of course,on uniprocessor systems,only one process can progress,but many can be blocked
			  in Kernel Mode when waiting for the CPU or the completion of some I/O operation.
			  reentrant functions : the functions they modify only local variables and do not alter global data 
			  	    	      	structures.
			  (reentrant functions,that is how some real-time kernels are implemented)
			  but kernel can include nonreentrant functions and use locking mechanisms to ensure that only one process
			  can execute a nonreentrant function at a time.

			  generial kernel control path :
			    Run process -> Timer interrupt -> Deal with interrupt -> Schedule tasks -> Run process -> ...

			  when one of the following events occurs,the CPU will enter a new path to do something :
			    >  a process executing in User Mode invokdes a system call.if the service would not be satisfied,
			       then scheduler pick next process to run,the former process enter sleeping until condition is
			       satisifed or wake up by a signal.
			       (system calls is triggered via soft interrupt,on x86,it is "int 0x80")
			    >  the CPU detects an exception.CPU must starts the execution of a suitable procedure.
			       after the procedure terminates,CPU return to the path before the exception is detected.
			    >  a hardware interrupt occurs,and the interrupts enabled.
			       CPU must starts processing another kernel control path to handle the interrupt.
			    >  an interrupt occurs while the CPU is running with kernel preemption enabled,and a higher priority
			       process is runnable.(lower intterupt could be preempted by higher interrupt)

			  three states of CPU current be :
			    >  running a process in User Mode			(process context)
			    >  running an exception or a system call handler	(process context)
			    >  running an interrupt handler	     		(interrupt context)

      Process Address Space - Each process runs in its private address space.A process running in User Mode refers to private stack,
      	      	      	      data,and code areas.when running in Kernel Mode,the process addresses the kernel data and code areas
			      and uses another private stack.
			      reentrant kernel,each kernel control path refers to its own private kernel stack.
			      sometimes,kernel shares process address space to another same program,certainly that is code area.
			      but process also can initiativly shares its address space to another different program.(IPC)

      Synchronization and Critical Regions - reentrant kernel requires the use of synchronization.
      		      	  	   	     if a kernel control path is suspended while acting on a kernel data structure,no other
					     kernel control path should be allowed to act on the same data structure unless it has
					     been reset to a consistent state.
					     critical region :
					       any section of code that should be finished by each process that begins it before
					       another process can enter it.

      Kernel preemption disabling - A synchronization mechanism applicable to preemptive kernel consists of disabling kernel 
      	     			    preemption before entering a critical region and reenabling it right after levaing the region.
				    nonpreemptability is not enough for multiprocessor systems,because two kernel control paths running
				    on different CPUs can concurrently access the same data structure.

      Interrupt disabling - Another synchronization mechanism for uniprocessor systems consists of disabling all hardware interrupts
      			    before entering a critical region and reenabling them right after leaving it.
			    if critical region is too large,this will down system efficiency;moreover,on a multiprocessor system,
			    disabling interrupts on the local CPU is not sufficient.

      Semaphores - A semaphore is simply a counter associated with a data structure;it is checked by all kernel threads before they
      		   try to access the data structure.
		   each semaphore may be viewed as an object composed of :
		     an integer variable
		     a list of waiting processes
		     two atomic method : down() and up()

		   down() decrease semaphore value,up() increase semaphore value.if its value is less than 0,process have to wait on
		   it until semaphore is available.

      Spin locks - some kernel data structures should be protected from being concurrently accessed by kernel control paths that run
      	   	   on different CPUs.in this case,if the time required to update the data structure is short,a semaphore could be very
		   inefficient.
		   a spink lock is very similar to semaphore,but it has no process list;when a process finds the lock closed by another
		   process,it "spins" around repeatedly,executing a tight instruction loop until the lock becomes open.
		   of course,spin locks are useless in a uniprocessor environment.

      Avoiding deadlocks - the simplest case of deadlock occurs when process p1 gains access to data structure a and process p2 gains
      	       		   access to b,but p1 then waits for b and p2 waits for a.
			   Several operating systems,including Linux,avoid this problem by requesting locks in a predefined order.

    Signals and Interprocess Communication :
      Unix signals provide a mechanism for notifying processes of system events.
      there are two kinds of system events :
        Asynchronous notifications
	Synchronous notifications

      POSIX standard defines about 20 different signals,2 of which are user-definable and may be used as a primitive mechanism for
      communication and synchronization among processes in UserMode.

      process may ignore the signal or asynchronously execute a specified procedure(signal handler),kernel provides the default
      signal handler for every signal.
      the default actions are :
        terminate the process
	write the execution context and the contents of the address space in a file(coredump) and terminate the process
	ignore the signal
	suspend the process
	resume the process's execution,if it was stopped

      SystemV IPC(AT&T's Unix System V) - semaphores, message queues, shared memory
      POSIX standard also defined some IPCs - posix semaphores, posix message queues, posix shared memory

    Process Management : 
      Unix makes a neat distinction between the process and the program it is executing.
      process is the program which is loadded into memory,it contains the resources all the program needs.
      the program it is executing,that means it had been loadded and the process is TASK_RUNNING.
      a parent process is such process it has been called fork() syscall,fork() would create a new process and its resources
      is duplicated to parent process,the process is child process.

      Copy-On-Write - this approach defers page duplication until the last moment(i.e., until the parent or the child is
      		      required to write into a page).
		      the naive implementation of fork() was quite time consuming.

      Zombie process - a process would exited if it called _exit(),and kernel send SIGCHLD to its parent.
      	     	       the zombie process is such process it had been exited but its status had not been checked,generally,
		       this work should be completed by its parent.
		       when the process exited,some resources are still effect and saved in its process address space,until
		       parent calls wait() systemcall to wait the process,that would destroy all resources.
		       if parent exited before wait its child,then kernel process init will adopts childs,that procedure calls
		       wait() periodically on its child processes.

      Process groups and login sessions - modern Unix operating systems introduce the notion of process groups to represent a 
      	      	     	       		  "job" abstraction.
					  a job,it might be combined by several processes,and they are in the same process group,
					  the group leader is the process whose PID is equal to the group ID.
					  a new process would be inserted into its parent's group initially.
					  normally,a job is treated as a single entity.
					  moder Unix kernels also introduce login sessions.
					  informally,a login session contains all processes that are descendants of the process that
					  has started a working session on a specific terminal--usually,the first command shell process
					  created for the user.
					  all processes in a process group must be in the same login session,a login session may have
					  several process groups active simultaneously;one of these process groups is always in the
					  foreground,which means that it has access to the terminal.others are in the background.

    Memory Management :
      Virtual memory -  all recent Unix systems provide a useful abstraction called virtual memory.
      	      	     	virtual memory acts as a logical layer between the application memory requests and the hardware
			Memory Management Unit.(MMU)
			its puposes and advantages :
			  several processes can be executed concurrently.
			  it is possible to run applications whose memory needs are larget than the available physical memory.
			  processes can execute a program whose code is only partially loaded in memory.
			  each process is allowed to access a subset of the available physical memory.
			  processes can share a single memory image of a library or program.
			  programs can be relocatable--that is,they can be placed anywhere in physical memory.
			  programmers can write machine-independent code,because they do not need to be concerned about physical
			  memory organization.
			the main ingredient of a virtual memory subsystem is the notion of virtual address space.

      Random access memory usage - all Unix operating systems clearly distinguish between two portions of the
      	     	    	   	   random access memory(RAM).a few megabytes are dedicated to storing the kernel
				   image.the remaining portion of RAM is usually handled by the virtual memory
				   system and is used in three possible ways :
				     to satisfy kernel requests for buffers,descriptors,and other dynamic kernel data structures.
				     to satisfy process requests for generic memory areas and for memory mapping of files.
				     to get better performance from disks and other buffered devices by means of caches.

      Kernel Memory Allocator - the kernel Memory Allocator(KMA) is a subsystem that tries to satisfy the requests fof memory areas
      	     	    	      	from all parts of the system.
				a good KMA should have the following features :
				  it must be fast.actually,this is the most crucial attribute,because it is invoked by all kernel
				  subsystems.
				  it should minimize the amount of wasted memory.
				  it should try to reduce the memory fragmentation problem.
				  it should be able to cooperate with the other memory management subsystems to borrow and release
				  page frames from them.
				all recent Unix operating systems adopt a memory allocation strategy called demand pagine.
				with demand paging,a process can start program execution with none of its pages in physical memory.

      Caching - a good part of the available physical memory is used as cache for hard disks and other block devices.this is because
      	      	hard drives are very slow.
		data read previously from disk and no longer used by any process continue to stay in RAM,and defer writing to disk as
		long as possible.
		the sync() system call forces disk synchronization by writing all of the "dirty" buffers into disk.to avoid data loss,
		all operating systems take care to periodically write dirty buffers back to disk.

    Device Drivers :
      the kernel interacts with I/O devices by means of device drivers.device drivers are included in the kernel and consist of
      data structures and functions that control one or more devices.
      each driver interacts with the remaining part of the kernel through a specific interface,this approach has the following
      advantages :
        >  device-specific code can be encapsulated in a specific module.
	>  vendors can add new devices without knowing ther kernel source code,only the interface specifications must be known.
	>  the kernel deals with all devices in a uniform way and accesses them through the same interface.
	>  it is possible to write a device driver as a module that can be dynamically loaded in the kernel without requiring
	   the system to be rebooted.it is also possible to dynamically unload a module that is no longer needed,therefore
	   minimizing the size of the kernel image strored in RAM.


Chapter 2 : Memory Addressing
    Memory Address :
      the three kinds of addresses on 80x86 microprocessors >
        1>  logical address
	    included in the machine language instructions to specify the address of an operand or of an instruction.
	    this type of address embodies the well-known 80x86 segmented architecture.
	    each logical address consists of a segment and an offset that denotes the distance from the start of
	    the segment to the actual address.

	2>  linear address(also known as virtual address)
	    a signle 32-bit unsigned integer that can be used to address up to 4GB.
	    linear addresses are usually represented in hexadecimal notation,their values range from
	    0x00000000 -- 0xffffffff

	3>  physical address
	    used to address memory cells in memory chips.
	    they correspond to the electrical signals sent along the address pins of the microprocessor to the memory bus.
	    they are represented as 32-bit or 36-bit unsigned integers.

      MMU Memory Management Unit,it transforms a logical address into a linear address by means of a hardware circuit called
      a segmentation unit.
      Page Unit,it transforms the linear address into a physical address.

      In multiprocessor systems,RAM chips may be accessed concurrently(CPUs share same memory).
      Memory Arbiter is inserted between the bus and every RAM chip,it is used to ensure serially operations perform.
      (if the RAM chip is free or it is busy servicing a request by another CPU(in this case,it delay the CPU's request))
      even uniprocessor systems use memory arbiters,because they include specialized processors called DMA(Direct Memory Access)
      controllers that operate concurrently with the CPU.
      (GPU might use DMA zone)

      /*  Memory Arbiter is unvisible to program  */

    Segmentation in Hardware :
      (80286 model)
      Intel microprocessors perform address translation in two different ways called "real mode" and "protected mode".

      Segment selectors and Segmentation registers :
        a logical address consists of two parts : a segment identifier and an offset that specifies the relative address
	within the segment.

	segment identifier : a 16-bit field called the segment selector.
	offset : a 32-bit field associated the segment identifier.

	processor provides six segmentation registers for retrive segment selector quickly :
	  cs, ss, ds, es, fs, gs
	program could reuse some segmentation registers,but have to store its contents in memory,and then
	restore it later.

	cs : code segment register,which points to a segment containing program instructions.
	ss : stack segment register,which points to a segment containing the current program stack.
	ds : data segment register,which points to a segment containing global and static data.
        
	the remaining three segmentation registers are general purpose and may refer to arbitrary data segments.

	cs register has another important function :
	  it includes a 2-bit field that specifies the Current Privilege Level(CPL) of the CPU.
	  value 0 denotes the highest privilege level,value 3 denotes the lowest one.
	  (Linux only use 0(kernel mode) and 3(user mode))

      Segment Descriptors : 
        Global Descriptor Table(GDT)
	Local Descriptor Table(LDT)

	each segment is represented by an 8-byte segment descriptor,they are stored either in GDT or LDT.
	program is allowed to have its own LDT,if it have to stores some segments besides those stored in GDT.

	gdtr : gdtr control register,it contains the address and size of the GDT in main memory.
	ldtr : ldtr control register,it contains the address and size of the current LDT in main memory.

	Format of Segment Descriptor : (every 8-byte 64-bit)
	  Field :
	    Base - contains the linear address of the first byte of the segment.
	    G - granularity flags,if it is cleared(0),the segment size is expressed in bytes;otherwise,it is
	      	expressed in multiples of 4096 bytes.
	    Limit - holds the offset of the last memory cell in the segment,thus binding the segment length.
	    S - system flag,if it is cleared(0),the segment is a system segment that stores critical data 
	      	structures such as the Local Descriptor Table;otherwise it is a normal code or data segment.
            Type - Characterizes the segment type and its access rights.
	    DPL - Descriptor Privilege Level,used to restrict accesses to the segment.it represents the minimal
	    	  CPU privilege level requested for accessing the segment.
            P - Segment-Present flag,it is equal to 0 if the segment is not stored currently in main memory.
	      	Linux always sets this flag (bit 47) to 1,because it never swaps out whole segments to disk.
            D or B - called D or B depending on whether the segment contains code or data.
	      	     its meaning is slightly different in the two cases,but it is basically set(equal to 1) if the
		     addresses used as segment offsets are 32 bits long,and it is cleared if they are 16 bits long.
	    AVL - may be used by the operating system,but it is ignored by Linux.

	  Composing :
	    0-15 : LIMIT (0-15)
	    16-31 : BASE (0-15)
	    32-39 : BASE (16-23)
	    40-43 : TYPE
	    44 : S
	    45-46 : DPL
	    47 : P
	    48-51 : LIMIT (16-19)
	    52 : AVL
	    53 : none
	    54 : D or B
	    55 : G
	    56-63 : BASE (24-31)

	The Segment Descriptors widely used in Linux :
	  Code Segment Descriptor -
	    it may be included either GDT or LDT,the descriptor has the S flag set.
	  Data Segment Descriptor - 
	    data segment.included either GDT or LDT,has S flag set.
	    stack segments are implemented by means of generic data segments.
	  Task State Segment Descriptor(TSSD) -
	    task state segment,it is a segment used to save the contents of the processor registers;it can appear
	    only in the GDT.The corresponding Type field has the value 11 or 9,depending on whether the corresponding
	    process is currently executing on a CPU.has no S flag.
	  Local Descriptor Table Descriptor(LDTD) -
	    a segment containing an LDT;it can appear only in the GDT.
	    the corresponding Type field has the value 2.has no S flag.
	    