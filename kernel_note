Linux Kernel note >

  Multiple ways to hook syscall :
    syscall table hijacking -- The good old way >
      hooking syscall via syscall table hijacking,this require write access syscall table.
      the syscall table is a mapping between syscall number and the kernel address of its implementation.
      but syscall table is write protecting,that is its address in kernel space is read only.
      
      CR0 register controls write protecting,if its 16th bit(WP bit) is opened,that is write protecting is enable,
      so close the bit to disable write protecting.

      the general ways to get sys_call_table :
        1>  grep /proc/kallsyms | grep -E sys_call_table \| ia32_sys_call_table
	    the file /proc/kallsyms contains all kernel symbols in kernel space.
        
	2>  call function "unsigned long kallsyms_lookup_name(@name)" which is defined in kallsyms.h,
	    it is used to get address of functions.
	    but in the newer kernel,this function becomes did not exported,that means can not call it
	    in kernel code.

	    e.g.
	      void *sys_call_open = (void *)kallsyms_lookup_name("sys_open");
	      void *sys_call_table_address = (void *)kallsyms_lookup_name("sys_call_table");

	      set_WP();  /*  disable WP  */
	      
	      sys_call_table_address[__NR_open] = (void *)my_sys_open;  /*  change address of sys_open  */

	      set_WP();  /*  enable WP  */

	    value __NR_<syscall_name> is the index of this syscall_name in sys_call_table.
	    value NR_syscalls is the total number of all syscalls is installed in sys_call_table.

        3>  read /boot/System.map-`uname -r` file to find address of sys_call_table.
	    this file is produced while compiling kernel,many kernel process read its text to find function's
	    address.
	    each line text has format : <address> <flag> <symbol name>

	    but kernel is not recommend read file from kernel space,if have to do,there is some interfaces
	    to help reading from kernel space :
	      filp_open
	      filp_close
	      vfs_read
	      vfs_write

	      /*  in newer version  */
	      kernel_read
	      kernel_write  /*  kernel_read and kernel_write dont updates loff_t object  */

	      some symbols is exported with GPL.
	      !!  vfs_read and vfs_write will test buffer address if it is from user space,that is they are
	      	  refuse kernel space address.
		  set_fs() and get_fs() to change behavior of address examining.
		  e.g.
		    mm_segment_t old_fs = get_fs();
		    set_fs(KERNEL_DS);
		    ...
		    set_fs(old_fs);

		  #  set_fs() will be abandoned in future.
		  #  possible value is KERNEL_DS and USER_DS

        4>  sys_close -- the brute force method
	    the sys_close() syscall is exported in older kernels,so there is a method to get sys_call_table,
	    that is traverse address from sys_close(),if encountered an address that is a void ** pointer and
	    at the unit index is __NR_close where saved sys_close()'s address,then this void ** pointer is the 
	    sys_call_table's address.
	    e.g.
	      unsigned long addr_sys_close = (unsigned long)sys_close;
	      unsigned long offset_addr = addr_sys_close;
	      while (offset_addr < ULLONG_MAX) {
	              if (((void **)offset_addr)[__NR_close] == addr_sys_close)
		              return offset_addr;
		      offset_addr += sizeof(void *);
	      }

	    dont recommend use this way to find sys_call_table.

    VFS hooking >
      the newer method to hooking file operation is the VFS hooking.
      VFS is virtual file-system,it is an abstract layer of file-system.
      process can accesses files with regardless of underlying file-system via VFS.
      the primary abstract objects in VFS is :
        super block object
	i_node object
	dentry object
	file object

	file.f_path(object).dentry(pointer).d_inode(pointer).i_sb(pointer)

	in inode structure,pointer i_op points to a structure which contains some methods to operates file-system.
	the inode object represents all the information needed by the kernel to manipulate a file or a directory.

	VFS hooking is use customized hook function to replaces the method in i_op object.
	be careful,must save the original method and hook function must use it to operates target file.

	e.g.
	  hooks lookup method >
	    struct file *fp = filp_open(...);
	    struct inode_operations *orig_inode_op = (struct inode_operations *)fp->f_path.dentry->d_inode->i_op;

	    ...  /*  disable WP  */
	    orig_inode_op->lookup = lookup_hook;
	    ...  /*  enable WP  */

        because this way would operates inode information,so all the operations calls to the look_up method to look
	up file under the directoy which inode associated will call the lookup_hook function.
	    
    The ftrace helper method >
      ftrace helper library uses kallsyms_lookup_name via kprobe to resolve symbol addresses.
      e.g.
	/*  resolving kallsyms_lookup_name address via kprobe  */
        #include <linux/kprobes.h>
	static struct kprobe kp = {
	       .symbol_name = "kallsyms_lookup_name"
	};

	kallsyms_lookup_name_t kallsyms_lookup_name;
	register_kprobe(&kp);
	kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
	unregister_kprobe(&kp);

	/*  kprobe is kernel probe as debug mechanism  */

      struct ftrace_hook {
      	     const char *name;  /*  name  */
	     void *function;    /*  hook  */
	     void *original;	/*  original  */

	     unsigned long address;  /*  address of original  */
	     struct ftrace_ops ops;
      };  /*  ftrace helper in ftrace library  */

      ftrace_ops.func is the callback function and will be called whenever the target syscall gets called.
      ftrace_ops.flags is flag field used to control behaviors.

      callback function has prototype :
        void notrace (*callback) (unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops,
	     	     		  struct pt_regs *regs);

	@ip : instruction pointer of the function that is being traced.
	@parent_ip : instruction pointer of the function that called the function being traced.
	@ops : a pointer to ftrace_ops that was used to register the callback.
	       this can be used to pass data to the callback via the private pointer.
	@regs : if the FTRACE_OPS_FL_SAVE_REGS or FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED flags are set in the
	        ftrace_ops structure,then this will be pointing to the pt_regs structure like it would be if
		an breakpoint was placed at the start of the function where ftrace was tracing.
		otherwise it either contains garbage,or NULL.

      ftrace_ops.flags is set with FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_IPMODIFY,
      then the original regs values would be saved(*regs) and passed inside callback,turn off ftrace's built-in
      recursion protection and to notify ftrace for rip modification respectively.

      register ftrace :
        int register_ftrace_function(struct ftrace_ops *);
	/*  enable tracing  */

      callback invocated when target syscall is called ->
      callback set rip to hook function ->
      hook function start execute

  ACPI NETLINKE message :
    Im looking for a way to monitor the contents changing of the file in sysfs.
    the target is battery object of class power_supply,i want to wait on event that
    battery start charging or stop charging.
    I have tried file descriptor multiplex and inotify,but unfortunately,both of them are
    designed for network file descriptor or the file descriptor which corresponding to
    a inode.
    So,I had dived into kernel ACPI driver.It is very complex,however,I found out there
    are come notifiers have attached to the driver,they would be called in function
    acpi_battery_notify().This driver function is called by driver to notify power
    event.
    If I want to listen on such power event,then I must have a kernel module who attach
    a new notifier to the power driver,and tell the process of User Mode that it is time
    to checks the content of sysfs file.
    If I determine to apply this method,then I must insert a new kernel module,it might cause
    kernel panic.Thus,I want to find out another way to help me solve this problem.
    Netlink message,acpi_battery_function() would create bus netlink message,it is type of
    netlink generic message,and payload is nlattr structure added acpi_genl_event structure.
    the NLA type is ACPI_GENL_ATTR_EVENT,and the type of event is reported by driver.
     
    [ nlmsghdr | pading | payload | pading | ... ]
                          |
                          +--> [ genlmsghdr |  [ nlahdr | pading | acpi_genl_event | pading ] | ... ]
                                                 |
                                                 +--> struct nlattr
    /**
     * unfortunately,the multicast group of ACPI event is registered dynamically,thus there is not way
     * to get the group id of ACPI event.even I tried to listen on some multicast groups,but no
     * netlink message has came.
     * may be I should try kobject uevent.
     */

    I have found out that the mcast group id and mcast group name both are inclued in a nested nlattr
    message,and for each of them,a nlattr header is prefixed.
    It seems like this -
                  7 => CTRL_ATTR_MCAST_GROUPS
      [ nla_len | nla_type | pading | payload | pading ]
                                      |                1 => CTRL_ATTR_MCAST_GRP_NAME
                                      +--> [ nla_len | nla_type | pading | payload | pading ]
                                                                           |
      +--------------------------------------------------------------------+
      |                                                                    
      V           2 => CTRL_ATTR_MCAST_GRP_ID                  1 => CTRL_ATTR_MCAST_GRP_NAME
      [ nla_len | nla_type | pading | ID | pading ][ nla_len | nla_type | pading | NAME | pading]
                                    __u16

    The information is got from the kernel documentation "generic-netlink" in "docs.kernel.org".
    # attribute message of CTRL_ATTR_MCAST_GROUPS included CTRL_ATTR_MCAST_GRP_ID attribute and
      CTRL_ATTR_MCAST_GRP_NAME attribute.

    And then,I tried to gdb the demo program,find out this relationship by use of "x/FMT" command.
    But it is strange that flag NLA_F_NESTED is not set in the @nla_type of first nlattr message.

    ACK message from kernel that corresponding to the previous GENL_ID_CTRL request is send to
    user-space in a short time,it will appears in the result of next recvmsg().

    Now I have succeed to subscribe the ACPI multicast group,so I can let program to read the
    specified sysfs files when ACPI event has came.

    ! Thanks to the github user "tedfelix",whose project "acpid2" told me the way how to get multicast
      group id of ACPI.
      

